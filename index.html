<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數獨遊戲</title>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 數獨格子的基本樣式 */
        .sudoku-cell {
            height: 100%; 
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            
            font-family: 'Inter', sans-serif;
            font-size: 1.6rem; /* 略微放大字體，視覺效果更好 */
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.1s;
            user-select: none;
            
            /* 預設邊框：細線，用於單格分隔 */
            border: 1px solid #d1d5db; /* 淺灰色 */
            box-sizing: border-box; 
            background-clip: padding-box;
            background-color: white; /* 確保底色是白色 */
        }
        
        /* 數獨主網格容器 */
        .sudoku-grid {
            display: grid;
            /* 移除外部粗邊框，讓粗線在內部定義 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        /* 動態粗格線樣式 (用於宮格分隔) */
        .thick-border-right {
            border-right-width: 3px;
            border-right-color: #4b5563; /* 深灰色 */
        }
        .thick-border-bottom {
            border-bottom-width: 3px;
            border-bottom-color: #4b5563; /* 深灰色 */
        }
        
        /* 確保最外層邊緣的粗線 */
        .sudoku-cell[data-col="3"][data-size="4"],
        .sudoku-cell[data-col="8"][data-size="9"] {
            border-right-width: 3px;
            border-right-color: #4b5563;
        }

        .sudoku-cell[data-row="3"][data-size="4"],
        .sudoku-cell[data-row="8"][data-size="9"] {
            border-bottom-width: 3px;
            border-bottom-color: #4b5563;
        }


        /* 選中、高亮和錯誤樣式 */
        .sudoku-cell.selected {
            background-color: #fcd34d; /* 較深的黃色，更容易區分 */
        }

        .sudoku-cell.highlighted {
            background-color: #fef9c3; /* 淺黃色，同行同列同宮格 */
        }

        .sudoku-cell.error {
            background-color: #fca5a5; /* 淺紅色，錯誤的格子 */
            color: #b91c1c !important; /* 錯誤數字用深紅色 */
        }

        .sudoku-cell.prefilled {
            font-weight: bold;
            color: #1f2937; /* 預設數字顏色 */
            background-color: #f3f4f6;
            cursor: default;
        }

        .input-btn {
            @apply p-4 m-1 w-12 h-12 text-xl font-bold rounded-lg shadow-lg transition duration-150 ease-in-out transform hover:scale-105;
        }
        
        @media (max-width: 640px) {
            .sudoku-cell {
                font-size: 1.25rem;
            }
            .input-btn {
                @apply p-3 m-0.5 w-10 h-10 text-lg;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">

    <div class="w-full max-w-lg bg-white p-6 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-extrabold text-gray-800 text-center mb-6">數獨遊戲</h1>
        
        <!-- 狀態與控制區塊 -->
        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 space-y-4 sm:space-y-0">
            
            <!-- 難度選擇 -->
            <div class="flex items-center space-x-2">
                <label for="difficulty" class="text-gray-600 font-medium whitespace-nowrap">難度:</label>
                <select id="difficulty" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    <option value="easy">簡單 (4x4)</option>
                    <option value="medium">進階 (9x9 簡單)</option>
                    <option value="hard">高級 (9x9 困難)</option>
                </select>
            </div>

            <!-- 計時器 -->
            <div id="timer" class="text-2xl font-mono text-gray-700 bg-gray-200 px-4 py-1 rounded-lg shadow-inner">00:00</div>
        </div>

        <!-- 數獨棋盤 -->
        <!-- aspect-square 確保棋盤容器為正方形 -->
        <div id="sudoku-grid-container" class="aspect-square w-full max-w-md mx-auto shadow-xl mb-6">
            <div id="sudoku-grid" class="sudoku-grid">
                <!-- 數獨格子將由 JavaScript 填充 -->
            </div>
        </div>
        
        <!-- 遊戲訊息 -->
        <div id="message" class="text-center h-8 mb-4 font-semibold text-lg text-red-600"></div>

        <!-- 數字輸入區塊 -->
        <div id="input-controls" class="flex justify-center flex-wrap mb-6">
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600" data-value="1">1</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600" data-value="2">2</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600" data-value="3">3</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600" data-value="4">4</button>
            <!-- 9x9 模式下才顯示 5-9 -->
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600 hidden number-5-9" data-value="5">5</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600 hidden number-5-9" data-value="6">6</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600 hidden number-5-9" data-value="7">7</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600 hidden number-5-9" data-value="8">8</button>
            <button class="input-btn bg-blue-500 text-white hover:bg-blue-600 hidden number-5-9" data-value="9">9</button>
            <button class="input-btn bg-red-400 text-white hover:bg-red-500" data-value="0">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button> <!-- 0 或清除按鈕 -->
        </div>

        <!-- 主要操作按鈕 -->
        <div class="flex flex-wrap justify-center gap-3">
            <button id="new-game-btn" class="flex-1 min-w-[150px] bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-xl hover:bg-green-600 transition transform hover:scale-[1.02]">
                開始新遊戲
            </button>
            <button id="check-btn" class="flex-1 min-w-[150px] bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg shadow-xl hover:bg-yellow-600 transition transform hover:scale-[1.02]">
                檢查答案
            </button>
        </div>
    </div>

    <script>
        // 數獨遊戲邏輯
        const puzzles = {
            "easy": {
                // 4x4 迷你數獨 (2x2 宮格)
                initial: [1,0,3,0,0,3,0,4,3,0,4,1,4,1,0,3],
                solution: [1,4,3,2,2,3,1,4,3,2,4,1,4,1,2,3],
                size: 4,
                boxSize: 2 // 2x2 box
            },
            "medium": {
                // 9x9 簡單級：起始數字較多 (約 40 個)
                initial: [3,1,6,5,0,8,4,0,0,5,2,9,1,0,4,6,8,7,4,8,7,6,0,9,5,3,1,2,6,3,4,1,5,9,8,7,9,4,1,8,6,3,7,2,5,7,5,8,9,2,0,6,1,3,1,3,4,7,8,6,2,5,9,6,9,2,3,5,1,8,7,4,8,7,5,2,4,0,3,1,9],
                solution: [3,1,6,5,7,8,4,9,2,5,2,9,1,3,4,6,8,7,4,8,7,6,2,9,5,3,1,2,6,3,4,1,5,9,8,7,9,4,1,8,6,3,7,2,5,7,5,8,9,2,4,6,1,3,1,3,4,7,8,6,2,5,9,6,9,2,3,5,1,8,7,4,8,7,5,2,4,6,3,1,9],
                size: 9,
                boxSize: 3 // 3x3 box
            },
            "hard": {
                // 9x9 高級級：起始數字最少 (約 25 個)
                initial: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,8,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,3,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                solution: [6,5,3,8,9,2,7,4,1,7,9,4,5,6,1,3,2,8,2,8,1,7,4,3,5,9,6,4,6,9,1,2,8,3,5,7,5,3,7,6,9,4,1,8,2,8,1,2,3,7,5,6,4,9,3,7,6,2,5,9,4,1,8,9,4,5,1,3,7,8,6,2,1,2,3,8,4,6,9,7,5],
                size: 9,
                boxSize: 3 // 3x3 box
            }
        };

        let currentPuzzle = []; // 儲存用戶輸入的當前盤面 (包括預設數字)
        let initialPuzzle = []; // 儲存遊戲開始時的預設盤面 (不會改變)
        let solution = []; // 儲存完整的解
        let selectedCell = null; // 當前選中的格子 {row: r, col: c}
        let timerInterval = null;
        let seconds = 0;
        let gridSize = 9; // 當前盤面大小 (N)
        let boxSize = 3; // 當前宮格大小 (B)
        
        const gridElement = document.getElementById('sudoku-grid');
        const messageElement = document.getElementById('message');
        const timerDisplay = document.getElementById('timer');
        const difficultySelect = document.getElementById('difficulty');
        const newGameBtn = document.getElementById('new-game-btn');
        const checkBtn = document.getElementById('check-btn');
        const inputButtons = document.querySelectorAll('#input-controls .input-btn');

        // --- 計時器功能 ---

        function startTimer() {
            clearInterval(timerInterval);
            seconds = 0;
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                seconds++;
                updateTimerDisplay();
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimerDisplay() {
            const minutes = String(Math.floor(seconds / 60)).padStart(2, '0');
            const remainingSeconds = String(seconds % 60).padStart(2, '0');
            timerDisplay.textContent = `${minutes}:${remainingSeconds}`;
        }

        // --- 遊戲初始化與狀態管理 ---

        /**
         * 根據選擇的難度初始化遊戲
         * @param {string} difficulty - "easy", "medium", or "hard"
         */
        function initializeGame(difficulty) {
            stopTimer(); // 停止舊的計時器
            
            const puzzleData = puzzles[difficulty];
            if (!puzzleData) {
                console.error("無效的難度設定:", difficulty);
                return;
            }

            // 設置當前遊戲的尺寸
            gridSize = puzzleData.size;
            boxSize = puzzleData.boxSize;
            
            initialPuzzle = [...puzzleData.initial]; // 複製初始盤面
            currentPuzzle = [...puzzleData.initial]; // 複製到當前盤面
            solution = puzzleData.solution;
            selectedCell = null;
            messageElement.textContent = '';
            
            // 根據尺寸調整輸入按鈕的顯示
            toggleInputButtons(gridSize);
            
            renderBoard();
            startTimer(); // 開始新的計時器
        }
        
        /**
         * 根據盤面大小切換輸入按鈕的顯示 (4x4 只顯示 1-4)
         * @param {number} size - 4 or 9
         */
        function toggleInputButtons(size) {
            document.querySelectorAll('.number-5-9').forEach(btn => {
                if (size === 4) {
                    btn.classList.add('hidden');
                } else {
                    btn.classList.remove('hidden');
                }
            });
        }

        /**
         * 繪製或更新數獨盤面
         */
        function renderBoard() {
            gridElement.innerHTML = ''; // 清空現有的格子
            
            // 設置 Grid 佈局樣式
            gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            gridElement.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;

            const totalCells = gridSize * gridSize;

            for (let i = 0; i < totalCells; i++) {
                const value = currentPuzzle[i];
                const r = Math.floor(i / gridSize);
                const c = i % gridSize;
                
                // 1. 創建格子元素
                const cell = document.createElement('div');
                cell.className = 'sudoku-cell'; 
                cell.dataset.index = i;
                cell.dataset.row = r;
                cell.dataset.col = c;
                cell.dataset.size = gridSize; // 儲存 gridSize 供 CSS 邊界處理

                // 2. 設置數字內容
                cell.textContent = value === 0 ? '' : value;
                
                // 3. 處理預設數字的樣式
                if (initialPuzzle[i] !== 0) {
                    cell.classList.add('prefilled');
                }
                
                // 4. 動態應用粗實線邊框 (不包含最後一行/列，最後一行/列會在 CSS 裡補齊)
                // 垂直粗線：在宮格的最後一列 (C+1) % boxSize === 0
                if ((c + 1) % boxSize === 0 && c !== gridSize - 1) {
                    cell.classList.add('thick-border-right');
                }
                // 水平粗線：在宮格的最後一行 (R+1) % boxSize === 0
                if ((r + 1) % boxSize === 0 && r !== gridSize - 1) {
                    cell.classList.add('thick-border-bottom');
                }
                
                // 5. 處理選中和高亮
                cell.onclick = (e) => handleCellClick(e);
                
                // 重置所有視覺狀態
                cell.classList.remove('selected', 'highlighted', 'error');

                gridElement.appendChild(cell);
            }
            
            // 重新應用選中和高亮狀態
            applyVisualState();
        }
        
        /**
         * 應用選中、高亮、錯誤的視覺狀態
         */
        function applyVisualState() {
            const allCells = gridElement.querySelectorAll('.sudoku-cell');
            allCells.forEach(cell => {
                cell.classList.remove('selected', 'highlighted', 'error');
            });

            if (!selectedCell) {
                // 如果沒有選中的格子，則執行錯誤檢查以保持錯誤狀態可見
                checkErrors(false); 
                return;
            }

            const N = gridSize;
            const B = boxSize;
            const selectedIndex = selectedCell.row * N + selectedCell.col;
            const selectedValue = currentPuzzle[selectedIndex];

            allCells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const index = parseInt(cell.dataset.index);

                // 1. 選中狀態
                if (r === selectedCell.row && c === selectedCell.col) {
                    cell.classList.add('selected');
                } 
                
                // 2. 高亮狀態 (同行、同列、同宮格)
                else if (r === selectedCell.row || c === selectedCell.col || 
                           (Math.floor(r / B) === Math.floor(selectedCell.row / B) && 
                            Math.floor(c / B) === Math.floor(selectedCell.col / B))) {
                    cell.classList.add('highlighted');
                }

                // 3. 相同數字高亮 (如果選中的格子有數字且不是預設數字)
                if (selectedValue !== 0 && currentPuzzle[index] === selectedValue) {
                    // 只有當格子不是選中的格子時才應用 highlighted，避免覆蓋 selected 樣式
                    if (r !== selectedCell.row || c !== selectedCell.col) {
                         cell.classList.add('highlighted');
                    }
                }
            });
            
            // 4. 錯誤狀態 (獨立執行以覆蓋其他高亮)
            checkErrors(true);
        }


        /**
         * 檢查整個盤面是否有任何錯誤 (不符合數獨規則)
         * @param {boolean} applyStyle - 是否立即應用 CSS 樣式
         * @returns {boolean} - true 如果有錯誤
         */
        function checkErrors(applyStyle = true) {
            let hasError = false;
            const errorCells = new Set(); // 儲存錯誤格子的索引
            const N = gridSize;
            const B = boxSize;

            // 輔助函數：檢查一個數組中是否有重複的非零數字
            const findDuplicates = (arr) => {
                const counts = {};
                const duplicates = new Set();
                arr.forEach((val) => {
                    if (val.value !== 0) {
                        if (counts[val.value]) {
                            counts[val.value].push(val.index);
                            counts[val.value].forEach(dupIndex => duplicates.add(dupIndex));
                        } else {
                            counts[val.value] = [val.index];
                        }
                    }
                });
                return duplicates;
            };

            // 1. 檢查行
            for (let r = 0; r < N; r++) {
                const rowValues = Array.from({ length: N }, (_, c) => ({ 
                    value: currentPuzzle[r * N + c], 
                    index: r * N + c 
                }));
                const rowDups = findDuplicates(rowValues);
                rowDups.forEach(index => errorCells.add(index));
            }

            // 2. 檢查列
            for (let c = 0; c < N; c++) {
                const colValues = Array.from({ length: N }, (_, r) => ({ 
                    value: currentPuzzle[r * N + c], 
                    index: r * N + c 
                }));
                const colDups = findDuplicates(colValues);
                colDups.forEach(index => errorCells.add(index));
            }

            // 3. 檢查 Bx B 宮格
            for (let br = 0; br < B; br++) { // Block row index
                for (let bc = 0; bc < B; bc++) { // Block column index
                    const blockValues = [];
                    for (let r = br * B; r < br * B + B; r++) {
                        for (let c = bc * B; c < bc * B + B; c++) {
                            const index = r * N + c;
                            blockValues.push({ value: currentPuzzle[index], index: index });
                        }
                    }
                    const blockDups = findDuplicates(blockValues);
                    blockDups.forEach(index => errorCells.add(index));
                }
            }

            // 應用錯誤樣式
            if (applyStyle) {
                 gridElement.querySelectorAll('.sudoku-cell').forEach((cell, index) => {
                    if (errorCells.has(index)) {
                        cell.classList.add('error');
                        hasError = true;
                    } else {
                        // 只有當格子沒有錯誤時，才移除 error 狀態
                        cell.classList.remove('error');
                    }
                });
            } else {
                hasError = errorCells.size > 0;
            }

            return hasError;
        }

        /**
         * 檢查使用者輸入的數字是否正確（與解比較）
         */
        function checkSolution() {
            stopTimer();
            let allCorrect = true;
            const N = gridSize;

            // 首先檢查數獨規則錯誤
            const hasRuleError = checkErrors(true);
            
            if (hasRuleError) {
                allCorrect = false;
            }

            // 接著檢查與答案的差異 (只檢查用戶輸入的格子)
            for (let i = 0; i < N * N; i++) {
                const cell = gridElement.querySelector(`[data-index="${i}"]`);
                if (initialPuzzle[i] === 0 && currentPuzzle[i] !== 0) {
                    if (currentPuzzle[i] !== solution[i]) {
                        cell.classList.add('error');
                        allCorrect = false;
                    } 
                    // 如果數字填寫正確，但因為規則錯誤 (如同行有重複) 已經被標紅，則保留紅色
                    else if (!hasRuleError && cell.classList.contains('error')) {
                        cell.classList.remove('error');
                    }
                }
            }
            
            if (allCorrect) {
                if (currentPuzzle.every(val => val !== 0)) {
                    messageElement.textContent = `恭喜！你成功解開了數獨！耗時：${timerDisplay.textContent}`;
                    messageElement.classList.remove('text-red-600');
                    messageElement.classList.add('text-green-600');
                } else {
                     messageElement.textContent = '目前填寫的數字都正確！但還沒完成喔！';
                     messageElement.classList.remove('text-red-600');
                     messageElement.classList.add('text-green-600');
                     startTimer(); // 繼續計時
                }
            } else {
                messageElement.textContent = '發現錯誤！紅色的格子需要修正。';
                messageElement.classList.remove('text-green-600');
                messageElement.classList.add('text-red-600');
                startTimer(); // 繼續計時
            }
        }

        /**
         * 處理格子被點擊的事件
         */
        function handleCellClick(e) {
            const clickedCell = e.currentTarget; 
            const index = parseInt(clickedCell.dataset.index);
            const r = parseInt(clickedCell.dataset.row);
            const c = parseInt(clickedCell.dataset.col);

            // 如果點擊的是預設數字，則不能選中
            if (initialPuzzle[index] !== 0) {
                selectedCell = null;
                applyVisualState();
                return;
            }

            // 更新選中狀態
            if (selectedCell && selectedCell.row === r && selectedCell.col === c) {
                selectedCell = null; // 取消選中
            } else {
                selectedCell = { row: r, col: c };
            }
            
            messageElement.textContent = ''; // 清除訊息
            applyVisualState();
        }

        /**
         * 處理數字按鈕被點擊的事件
         */
        function handleNumberInput(e) {
            if (!selectedCell) {
                messageElement.textContent = '請先點擊一個空白格子！';
                return;
            }
            
            const value = parseInt(e.currentTarget.dataset.value); // 0-9
            
            // 檢查輸入的數字是否在當前盤面的範圍內 (4x4 只能輸入 1-4)
            if (value > gridSize) {
                messageElement.textContent = `在 ${gridSize}x${gridSize} 模式下，只能輸入 1 到 ${gridSize} 的數字。`;
                return;
            }

            const index = selectedCell.row * gridSize + selectedCell.col;
            
            // 如果點擊的是預設數字的格子
            if (initialPuzzle[index] !== 0) {
                messageElement.textContent = '這個格子是預設數字，不能修改！';
                return;
            }

            // 更新當前盤面
            currentPuzzle[index] = value;
            
            // 更新 UI 顯示 (直接更新 cell 的內容)
            const cellElement = gridElement.querySelector(`[data-index="${index}"]`);
            cellElement.textContent = value === 0 ? '' : value;
            
            // 清除訊息和錯誤提示，重新應用高亮
            messageElement.textContent = ''; 
            
            // 執行一次規則錯誤檢查並應用樣式
            checkErrors(true); 
            applyVisualState();

            // 檢查是否完成
            if (currentPuzzle.every(val => val !== 0) && !checkErrors(false)) {
                stopTimer();
                messageElement.textContent = `恭喜！你成功解開了數獨！耗時：${timerDisplay.textContent}`;
                messageElement.classList.remove('text-red-600');
                messageElement.classList.add('text-green-600');
            }
        }
        
        // --- 事件監聽器設定 ---

        // 監聽難度選擇下拉選單：只要值改變，就自動開始新遊戲
        difficultySelect.addEventListener('change', () => {
            const difficulty = difficultySelect.value;
            initializeGame(difficulty);
        });
        
        // 監聽「開始新遊戲」按鈕
        newGameBtn.addEventListener('click', () => {
            const difficulty = difficultySelect.value;
            initializeGame(difficulty);
        });

        // 監聽「檢查答案」按鈕
        checkBtn.addEventListener('click', checkSolution);

        // 監聽數字輸入按鈕
        inputButtons.forEach(button => {
            button.addEventListener('click', handleNumberInput);
        });
        
        // 監聽鍵盤輸入
        document.addEventListener('keydown', (e) => {
            const N = gridSize;
            
            if (e.key >= '1' && e.key <= String(N)) {
                // 模擬點擊數字按鈕 (在盤面大小範圍內)
                const button = document.querySelector(`[data-value="${e.key}"]`);
                if (button) button.click();
            } else if (e.key === 'Delete' || e.key === 'Backspace' || e.key === '0') {
                // 模擬點擊清除按鈕
                const button = document.querySelector(`[data-value="0"]`);
                if (button) button.click();
            } else if (selectedCell) {
                // 處理方向鍵移動
                let newRow = selectedCell.row;
                let newCol = selectedCell.col;
                let moved = false;

                if (e.key === 'ArrowUp') { newRow = Math.max(0, newRow - 1); moved = true; }
                else if (e.key === 'ArrowDown') { newRow = Math.min(N - 1, newRow + 1); moved = true; }
                else if (e.key === 'ArrowLeft') { newCol = Math.max(0, newCol - 1); moved = true; }
                else if (e.key === 'ArrowRight') { newCol = Math.min(N - 1, newCol + 1); moved = true; }

                if (moved) {
                    e.preventDefault();
                    
                    selectedCell = { row: newRow, col: newCol };
                    
                    // 檢查移動後是否為預設數字，如果是，則取消選中，只保留高亮
                    const index = newRow * N + newCol;
                    if (initialPuzzle[index] !== 0) {
                        selectedCell = null;
                    }

                    applyVisualState();
                }
            }
        });

        // 頁面載入時，自動初始化一個簡單的遊戲
        window.onload = () => {
            initializeGame(difficultySelect.value);
        };

    </script>
</body>
</html>
